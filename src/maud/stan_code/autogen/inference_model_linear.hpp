// Code generated by Stan version 2.20.0

#include <stan/model/model_header.hpp>

namespace inference_model_linear_model_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "/Users/tedgro/Code/Maud/maud/stan_code/autogen/inference_model_linear.stan");
    reader.add_event(1, 1, "include", "big_k_rate_equations.stan");
    reader.add_event(1, 0, "start", "big_k_rate_equations.stan");
    reader.add_event(62, 61, "end", "big_k_rate_equations.stan");
    reader.add_event(62, 2, "restart", "/Users/tedgro/Code/Maud/maud/stan_code/autogen/inference_model_linear.stan");
    reader.add_event(62, 2, "include", "haldane_relationships.stan");
    reader.add_event(62, 0, "start", "haldane_relationships.stan");
    reader.add_event(93, 31, "end", "haldane_relationships.stan");
    reader.add_event(93, 3, "restart", "/Users/tedgro/Code/Maud/maud/stan_code/autogen/inference_model_linear.stan");
    reader.add_event(93, 3, "include", "allostery.stan");
    reader.add_event(93, 0, "start", "allostery.stan");
    reader.add_event(125, 32, "end", "allostery.stan");
    reader.add_event(125, 4, "restart", "/Users/tedgro/Code/Maud/maud/stan_code/autogen/inference_model_linear.stan");
    reader.add_event(245, 122, "end", "/Users/tedgro/Code/Maud/maud/stan_code/autogen/inference_model_linear.stan");
    return reader;
}

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
uniuni(const T0__& A,
           const T1__& P,
           const T2__& V1,
           const T3__& V2,
           const T4__& Ka,
           const T5__& Keq, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 18;
        local_scalar_t__ num(DUMMY_VAR__);
        (void) num;  // dummy to suppress unused var warning
        stan::math::initialize(num, DUMMY_VAR__);
        stan::math::fill(num, DUMMY_VAR__);
        stan::math::assign(num,((V1 * V2) * (A - (P / Keq))));

        current_statement_begin__ = 19;
        local_scalar_t__ denom(DUMMY_VAR__);
        (void) denom;  // dummy to suppress unused var warning
        stan::math::initialize(denom, DUMMY_VAR__);
        stan::math::fill(denom, DUMMY_VAR__);
        stan::math::assign(denom,(((Ka * V2) + (V2 * A)) + ((V1 * P) / Keq)));


        current_statement_begin__ = 20;
        return stan::math::promote_scalar<fun_return_scalar_t__>((num / denom));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct uniuni_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
    operator()(const T0__& A,
           const T1__& P,
           const T2__& V1,
           const T3__& V2,
           const T4__& Ka,
           const T5__& Keq, std::ostream* pstream__) const {
        return uniuni(A, P, V1, V2, Ka, Keq, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, typename T10__, typename T11__, typename T12__, typename T13__, typename T14__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__, T10__, T11__, typename boost::math::tools::promote_args<T12__, T13__, T14__>::type>::type>::type>::type
ordered_bibi(const T0__& A,
                 const T1__& B,
                 const T2__& P,
                 const T3__& Q,
                 const T4__& V1,
                 const T5__& V2,
                 const T6__& Ka,
                 const T7__& Kb,
                 const T8__& Kp,
                 const T9__& Kq,
                 const T10__& Kia,
                 const T11__& Kib,
                 const T12__& Kip,
                 const T13__& Kiq,
                 const T14__& Keq, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__, T10__, T11__, typename boost::math::tools::promote_args<T12__, T13__, T14__>::type>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 27;
        local_scalar_t__ num(DUMMY_VAR__);
        (void) num;  // dummy to suppress unused var warning
        stan::math::initialize(num, DUMMY_VAR__);
        stan::math::fill(num, DUMMY_VAR__);
        stan::math::assign(num,((V1 * V2) * ((A * B) - ((P * Q) / Keq))));

        current_statement_begin__ = 28;
        local_scalar_t__ denom(DUMMY_VAR__);
        (void) denom;  // dummy to suppress unused var warning
        stan::math::initialize(denom, DUMMY_VAR__);
        stan::math::fill(denom, DUMMY_VAR__);
        stan::math::assign(denom,((((((((((((Kia * Kb) * V2) + ((Kb * V2) * A)) + ((Ka * V2) * B)) + ((V2 * A) * B)) + (((Kq * V1) * P) / Keq)) + (((Kp * V1) * Q) / Keq)) + (((V1 * P) * Q) / Keq)) + ((((Kq * V1) * A) * P) / (Kia * Keq))) + ((((Ka * V2) * B) * Q) / Kiq)) + ((((V2 * A) * B) * P) / Kip)) + ((((V1 * B) * P) * Q) / (Kib * Keq))));


        current_statement_begin__ = 40;
        return stan::math::promote_scalar<fun_return_scalar_t__>((num / denom));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ordered_bibi_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, typename T10__, typename T11__, typename T12__, typename T13__, typename T14__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__, T10__, T11__, typename boost::math::tools::promote_args<T12__, T13__, T14__>::type>::type>::type>::type
    operator()(const T0__& A,
                 const T1__& B,
                 const T2__& P,
                 const T3__& Q,
                 const T4__& V1,
                 const T5__& V2,
                 const T6__& Ka,
                 const T7__& Kb,
                 const T8__& Kp,
                 const T9__& Kq,
                 const T10__& Kia,
                 const T11__& Kib,
                 const T12__& Kip,
                 const T13__& Kiq,
                 const T14__& Keq, std::ostream* pstream__) const {
        return ordered_bibi(A, B, P, Q, V1, V2, Ka, Kb, Kp, Kq, Kia, Kib, Kip, Kiq, Keq, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__, T10__, T11__>::type>::type>::type
ordered_unibi(const T0__& A,
                  const T1__& P,
                  const T2__& Q,
                  const T3__& V1,
                  const T4__& V2,
                  const T5__& Ka,
                  const T6__& Kp,
                  const T7__& Kq,
                  const T8__& Kia,
                  const T9__& Kip,
                  const T10__& Kiq,
                  const T11__& Keq, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__, T10__, T11__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 47;
        local_scalar_t__ num(DUMMY_VAR__);
        (void) num;  // dummy to suppress unused var warning
        stan::math::initialize(num, DUMMY_VAR__);
        stan::math::fill(num, DUMMY_VAR__);
        stan::math::assign(num,((V1 * V2) * (A - ((P * Q) / Keq))));

        current_statement_begin__ = 48;
        local_scalar_t__ denom(DUMMY_VAR__);
        (void) denom;  // dummy to suppress unused var warning
        stan::math::initialize(denom, DUMMY_VAR__);
        stan::math::fill(denom, DUMMY_VAR__);
        stan::math::assign(denom,((((((Ka * V2) + (V2 * A)) + (((Kq * V1) * P) / Keq)) + (((Kp * V1) * Q) / Keq)) + (((V1 * P) * Q) / Keq)) + (((V2 * A) * P) / Kip)));


        current_statement_begin__ = 55;
        return stan::math::promote_scalar<fun_return_scalar_t__>((num / denom));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ordered_unibi_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__, T10__, T11__>::type>::type>::type
    operator()(const T0__& A,
                  const T1__& P,
                  const T2__& Q,
                  const T3__& V1,
                  const T4__& V2,
                  const T5__& Ka,
                  const T6__& Kp,
                  const T7__& Kq,
                  const T8__& Kia,
                  const T9__& Kip,
                  const T10__& Kiq,
                  const T11__& Keq, std::ostream* pstream__) const {
        return ordered_unibi(A, P, Q, V1, V2, Ka, Kp, Kq, Kia, Kip, Kiq, Keq, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
irr_mass_action(const T0__& A,
                    const T1__& V1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 58;
        return stan::math::promote_scalar<fun_return_scalar_t__>((A * V1));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct irr_mass_action_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& A,
                    const T1__& V1, std::ostream* pstream__) const {
        return irr_mass_action(A, V1, pstream__);
    }
};

template <typename T0__>
typename boost::math::tools::promote_args<T0__>::type
fixed_flux(const T0__& f, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 61;
        return stan::math::promote_scalar<fun_return_scalar_t__>(f);
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct fixed_flux_functor__ {
    template <typename T0__>
        typename boost::math::tools::promote_args<T0__>::type
    operator()(const T0__& f, std::ostream* pstream__) const {
        return fixed_flux(f, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
get_Kp_uniuni(const T0__& V1,
                  const T1__& Ka,
                  const T2__& V2,
                  const T3__& Keq, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 75;
        return stan::math::promote_scalar<fun_return_scalar_t__>((((Keq * V2) * Ka) / V1));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct get_Kp_uniuni_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type
    operator()(const T0__& V1,
                  const T1__& Ka,
                  const T2__& V2,
                  const T3__& Keq, std::ostream* pstream__) const {
        return get_Kp_uniuni(V1, Ka, V2, Keq, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
get_Kip_ordered_unibi(const T0__& Keq,
                          const T1__& Kia,
                          const T2__& Kq,
                          const T3__& V1,
                          const T4__& V2, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 78;
        return stan::math::promote_scalar<fun_return_scalar_t__>((((Keq * Kia) * V2) / (Kq * V1)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct get_Kip_ordered_unibi_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& Keq,
                          const T1__& Kia,
                          const T2__& Kq,
                          const T3__& V1,
                          const T4__& V2, std::ostream* pstream__) const {
        return get_Kip_ordered_unibi(Keq, Kia, Kq, V1, V2, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
get_Kiq_ordered_unibi(const T0__& Keq,
                          const T1__& Ka,
                          const T2__& Kp,
                          const T3__& V1,
                          const T4__& V2, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 81;
        return stan::math::promote_scalar<fun_return_scalar_t__>((((Keq * V2) * Ka) / (V1 * Kp)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct get_Kiq_ordered_unibi_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& Keq,
                          const T1__& Ka,
                          const T2__& Kp,
                          const T3__& V1,
                          const T4__& V2, std::ostream* pstream__) const {
        return get_Kiq_ordered_unibi(Keq, Ka, Kp, V1, V2, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__>::type>::type
get_Kip_ordered_bibi(const T0__& Keq,
                         const T1__& Ka,
                         const T2__& Kq,
                         const T3__& Kib,
                         const T4__& Kiq,
                         const T5__& V1,
                         const T6__& V2, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 84;
        return stan::math::promote_scalar<fun_return_scalar_t__>(((((Ka * Keq) * Kib) * pow(V2, 2)) / (Kq * pow(V1, 2))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct get_Kip_ordered_bibi_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__>::type>::type
    operator()(const T0__& Keq,
                         const T1__& Ka,
                         const T2__& Kq,
                         const T3__& Kib,
                         const T4__& Kiq,
                         const T5__& V1,
                         const T6__& V2, std::ostream* pstream__) const {
        return get_Kip_ordered_bibi(Keq, Ka, Kq, Kib, Kiq, V1, V2, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
get_Kia_ordered_bibi(const T0__& Keq,
                         const T1__& Kb,
                         const T2__& Kp,
                         const T3__& Kiq,
                         const T4__& V1,
                         const T5__& V2, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 87;
        return stan::math::promote_scalar<fun_return_scalar_t__>((((V1 * Kp) * Kiq) / ((V2 * Keq) * Kb)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct get_Kia_ordered_bibi_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
    operator()(const T0__& Keq,
                         const T1__& Kb,
                         const T2__& Kp,
                         const T3__& Kiq,
                         const T4__& V1,
                         const T5__& V2, std::ostream* pstream__) const {
        return get_Kia_ordered_bibi(Keq, Kb, Kp, Kiq, V1, V2, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
get_Keq(const T0__& delta_g,
            const T1__& T,
            const T2__& R, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 92;
        return stan::math::promote_scalar<fun_return_scalar_t__>(stan::math::exp((delta_g / (-(R) * T))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct get_Keq_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& delta_g,
            const T1__& T,
            const T2__& R, std::ostream* pstream__) const {
        return get_Keq(delta_g, T, R, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
get_regulatory_effect(const std::vector<T0__>& activator_concentration,
                          const std::vector<T1__>& inhibitor_concentration,
                          const T2__& free_enzyme_ratio,
                          const std::vector<T3__>& dissociation_constant_r,
                          const std::vector<T4__>& dissociation_constant_t,
                          const T5__& transfer_constant, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 100;
        local_scalar_t__ Q_num(DUMMY_VAR__);
        (void) Q_num;  // dummy to suppress unused var warning
        stan::math::initialize(Q_num, DUMMY_VAR__);
        stan::math::fill(Q_num, DUMMY_VAR__);
        stan::math::assign(Q_num,(logical_eq(size(inhibitor_concentration), 0) ? stan::math::promote_scalar<local_scalar_t__>(1) : stan::math::promote_scalar<local_scalar_t__>((1 + sum(elt_divide(to_vector(inhibitor_concentration), to_vector(dissociation_constant_t))))) ));

        current_statement_begin__ = 102;
        local_scalar_t__ Q_denom(DUMMY_VAR__);
        (void) Q_denom;  // dummy to suppress unused var warning
        stan::math::initialize(Q_denom, DUMMY_VAR__);
        stan::math::fill(Q_denom, DUMMY_VAR__);
        stan::math::assign(Q_denom,(logical_eq(size(activator_concentration), 0) ? stan::math::promote_scalar<local_scalar_t__>(1) : stan::math::promote_scalar<local_scalar_t__>((1 + sum(elt_divide(to_vector(activator_concentration), to_vector(dissociation_constant_r))))) ));

        current_statement_begin__ = 104;
        local_scalar_t__ Q(DUMMY_VAR__);
        (void) Q;  // dummy to suppress unused var warning
        stan::math::initialize(Q, DUMMY_VAR__);
        stan::math::fill(Q, DUMMY_VAR__);
        stan::math::assign(Q,(((transfer_constant * free_enzyme_ratio) * Q_num) / Q_denom));


        current_statement_begin__ = 105;
        return stan::math::promote_scalar<fun_return_scalar_t__>(inv((1 + Q)));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct get_regulatory_effect_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
    operator()(const std::vector<T0__>& activator_concentration,
                          const std::vector<T1__>& inhibitor_concentration,
                          const T2__& free_enzyme_ratio,
                          const std::vector<T3__>& dissociation_constant_r,
                          const std::vector<T4__>& dissociation_constant_t,
                          const T5__& transfer_constant, std::ostream* pstream__) const {
        return get_regulatory_effect(activator_concentration, inhibitor_concentration, free_enzyme_ratio, dissociation_constant_r, dissociation_constant_t, transfer_constant, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
get_free_enzyme_ratio_uniuni(const T0__& A,
                                 const T1__& P,
                                 const T2__& V1,
                                 const T3__& V2,
                                 const T4__& Ka,
                                 const T5__& Keq, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 108;
        local_scalar_t__ Kp(DUMMY_VAR__);
        (void) Kp;  // dummy to suppress unused var warning
        stan::math::initialize(Kp, DUMMY_VAR__);
        stan::math::fill(Kp, DUMMY_VAR__);
        stan::math::assign(Kp,get_Kp_uniuni(V1, Ka, V2, Keq, pstream__));


        current_statement_begin__ = 109;
        return stan::math::promote_scalar<fun_return_scalar_t__>((1 / ((1 + (A / Ka)) + (P / Kp))));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct get_free_enzyme_ratio_uniuni_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type
    operator()(const T0__& A,
                                 const T1__& P,
                                 const T2__& V1,
                                 const T3__& V2,
                                 const T4__& Ka,
                                 const T5__& Keq, std::ostream* pstream__) const {
        return get_free_enzyme_ratio_uniuni(A, P, V1, V2, Ka, Keq, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__, T10__, T11__>::type>::type>::type
get_free_enzyme_ratio_ordered_unibi(const T0__& A,
                                        const T1__& P,
                                        const T2__& Q,
                                        const T3__& V1,
                                        const T4__& V2,
                                        const T5__& Ka,
                                        const T6__& Kp,
                                        const T7__& Kq,
                                        const T8__& Kia,
                                        const T9__& Kip,
                                        const T10__& Kiq,
                                        const T11__& Keq, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__, T10__, T11__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 116;
        local_scalar_t__ num(DUMMY_VAR__);
        (void) num;  // dummy to suppress unused var warning
        stan::math::initialize(num, DUMMY_VAR__);
        stan::math::fill(num, DUMMY_VAR__);
        stan::math::assign(num,((Ka * V2) + (((Kq * V1) * P) / Keq)));

        current_statement_begin__ = 117;
        local_scalar_t__ denom(DUMMY_VAR__);
        (void) denom;  // dummy to suppress unused var warning
        stan::math::initialize(denom, DUMMY_VAR__);
        stan::math::fill(denom, DUMMY_VAR__);
        stan::math::assign(denom,((((((Ka * V2) + (V2 * A)) + (((Kq * V1) * P) / Keq)) + (((Kp * V1) * Q) / Keq)) + (((V1 * P) * Q) / Keq)) + (((V2 * A) * P) / Kip)));


        current_statement_begin__ = 124;
        return stan::math::promote_scalar<fun_return_scalar_t__>((num / denom));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct get_free_enzyme_ratio_ordered_unibi_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__, T10__, T11__>::type>::type>::type
    operator()(const T0__& A,
                                        const T1__& P,
                                        const T2__& Q,
                                        const T3__& V1,
                                        const T4__& V2,
                                        const T5__& Ka,
                                        const T6__& Kp,
                                        const T7__& Kq,
                                        const T8__& Kia,
                                        const T9__& Kip,
                                        const T10__& Kiq,
                                        const T11__& Keq, std::ostream* pstream__) const {
        return get_free_enzyme_ratio_ordered_unibi(A, P, Q, V1, V2, Ka, Kp, Kq, Kia, Kip, Kiq, Keq, pstream__);
    }
};

template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
get_fluxes(const std::vector<T0__>& m,
               const std::vector<T1__>& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 127;
        validate_non_negative_index("empty_array", "0", 0);
        std::vector<local_scalar_t__  > empty_array(0, local_scalar_t__(DUMMY_VAR__));
        stan::math::initialize(empty_array, DUMMY_VAR__);
        stan::math::fill(empty_array, DUMMY_VAR__);

        current_statement_begin__ = 128;
        local_scalar_t__ free_enzyme_ratio_r2(DUMMY_VAR__);
        (void) free_enzyme_ratio_r2;  // dummy to suppress unused var warning
        stan::math::initialize(free_enzyme_ratio_r2, DUMMY_VAR__);
        stan::math::fill(free_enzyme_ratio_r2, DUMMY_VAR__);
        stan::math::assign(free_enzyme_ratio_r2,get_free_enzyme_ratio_uniuni(get_base1(m, 3, "m", 1), get_base1(m, 4, "m", 1), (get_base1(p, 2, "p", 1) * get_base1(p, 9, "p", 1)), (get_base1(p, 2, "p", 1) * get_base1(p, 10, "p", 1)), get_base1(p, 11, "p", 1), get_base1(p, 8, "p", 1), pstream__));


        current_statement_begin__ = 129;
        return stan::math::promote_scalar<fun_return_scalar_t__>(transpose(stan::math::to_row_vector(stan::math::array_builder<local_scalar_t__ >().add(uniuni(get_base1(m, 1, "m", 1), get_base1(m, 3, "m", 1), (get_base1(p, 1, "p", 1) * get_base1(p, 5, "p", 1)), (get_base1(p, 1, "p", 1) * get_base1(p, 6, "p", 1)), get_base1(p, 7, "p", 1), get_base1(p, 4, "p", 1), pstream__)).add((uniuni(get_base1(m, 3, "m", 1), get_base1(m, 4, "m", 1), (get_base1(p, 2, "p", 1) * get_base1(p, 9, "p", 1)), (get_base1(p, 2, "p", 1) * get_base1(p, 10, "p", 1)), get_base1(p, 11, "p", 1), get_base1(p, 8, "p", 1), pstream__) * get_regulatory_effect(empty_array, static_cast<std::vector<local_scalar_t__> >(stan::math::array_builder<local_scalar_t__ >().add(get_base1(m, 3, "m", 1)).array()), free_enzyme_ratio_r2, empty_array, static_cast<std::vector<local_scalar_t__> >(stan::math::array_builder<local_scalar_t__ >().add(get_base1(p, 13, "p", 1)).array()), get_base1(p, 12, "p", 1), pstream__))).add(uniuni(get_base1(m, 4, "m", 1), get_base1(m, 2, "m", 1), (get_base1(p, 3, "p", 1) * get_base1(p, 15, "p", 1)), (get_base1(p, 3, "p", 1) * get_base1(p, 16, "p", 1)), get_base1(p, 17, "p", 1), get_base1(p, 14, "p", 1), pstream__)).array())));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct get_fluxes_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
    operator()(const std::vector<T0__>& m,
               const std::vector<T1__>& p, std::ostream* pstream__) const {
        return get_fluxes(m, p, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type>
ode_func(const T0__& t,
             const std::vector<T1__>& m,
             const std::vector<T2__>& p,
             const std::vector<T3__>& xr,
             const std::vector<int>& xi, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 136;
        validate_non_negative_index("fluxes", "3", 3);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> fluxes(3);
        stan::math::initialize(fluxes, DUMMY_VAR__);
        stan::math::fill(fluxes, DUMMY_VAR__);
        stan::math::assign(fluxes,get_fluxes(m, p, pstream__));


        current_statement_begin__ = 137;
        return stan::math::promote_scalar<fun_return_scalar_t__>(static_cast<std::vector<local_scalar_t__> >(stan::math::array_builder<local_scalar_t__ >().add(0).add(0).add(((1 * get_base1(fluxes, 1, "fluxes", 1)) - (1 * get_base1(fluxes, 2, "fluxes", 1)))).add(((1 * get_base1(fluxes, 2, "fluxes", 1)) - (1 * get_base1(fluxes, 3, "fluxes", 1)))).array()));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ode_func_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type>
    operator()(const T0__& t,
             const std::vector<T1__>& m,
             const std::vector<T2__>& p,
             const std::vector<T3__>& xr,
             const std::vector<int>& xi, std::ostream* pstream__) const {
        return ode_func(t, m, p, xr, xi, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, 1>
steady_state_function(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& balanced,
                          const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& theta,
                          const std::vector<T2__>& xr,
                          const std::vector<int>& xi, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 145;
        int N_unbalanced(0);
        (void) N_unbalanced;  // dummy to suppress unused var warning
        stan::math::fill(N_unbalanced, std::numeric_limits<int>::min());
        stan::math::assign(N_unbalanced,2);

        current_statement_begin__ = 146;
        int N_balanced(0);
        (void) N_balanced;  // dummy to suppress unused var warning
        stan::math::fill(N_balanced, std::numeric_limits<int>::min());
        stan::math::assign(N_balanced,2);

        current_statement_begin__ = 147;
        local_scalar_t__ initial_time(DUMMY_VAR__);
        (void) initial_time;  // dummy to suppress unused var warning
        stan::math::initialize(initial_time, DUMMY_VAR__);
        stan::math::fill(initial_time, DUMMY_VAR__);
        stan::math::assign(initial_time,0);

        current_statement_begin__ = 148;
        local_scalar_t__ time_step(DUMMY_VAR__);
        (void) time_step;  // dummy to suppress unused var warning
        stan::math::initialize(time_step, DUMMY_VAR__);
        stan::math::fill(time_step, DUMMY_VAR__);
        stan::math::assign(time_step,0.05);

        current_statement_begin__ = 149;
        validate_non_negative_index("conc", "4", 4);
        std::vector<local_scalar_t__  > conc(4, local_scalar_t__(DUMMY_VAR__));
        stan::math::initialize(conc, DUMMY_VAR__);
        stan::math::fill(conc, DUMMY_VAR__);

        current_statement_begin__ = 150;
        validate_non_negative_index("balanced_new", "2", 2);
        std::vector<local_scalar_t__  > balanced_new(2, local_scalar_t__(DUMMY_VAR__));
        stan::math::initialize(balanced_new, DUMMY_VAR__);
        stan::math::fill(balanced_new, DUMMY_VAR__);


        current_statement_begin__ = 151;
        stan::model::assign(conc, 
                    stan::model::cons_list(stan::model::index_multi(static_cast<std::vector<int> >(stan::math::array_builder<int >().add(3).add(4).array())), stan::model::nil_index_list()), 
                    to_array_1d(balanced), 
                    "assigning variable conc");
        current_statement_begin__ = 152;
        stan::model::assign(conc, 
                    stan::model::cons_list(stan::model::index_multi(static_cast<std::vector<int> >(stan::math::array_builder<int >().add(1).add(2).array())), stan::model::nil_index_list()), 
                    to_array_1d(stan::model::rvalue(theta, stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list()), "theta")), 
                    "assigning variable conc");
        current_statement_begin__ = 153;
        stan::math::assign(balanced_new, stan::model::rvalue(integrate_ode_bdf(ode_func_functor__(), conc, initial_time, rep_array(time_step, 1), to_array_1d(stan::model::rvalue(theta, stan::model::cons_list(stan::model::index_min((N_unbalanced + 1)), stan::model::nil_index_list()), "theta")), xr, rep_array(0, 1), pstream__, 1e-8, 1e-8, 1e5), stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_multi(static_cast<std::vector<int> >(stan::math::array_builder<int >().add(3).add(4).array())), stan::model::nil_index_list())), "integrate_ode_bdf(ode_func_functor__(), conc, initial_time, rep_array(time_step, 1), to_array_1d(theta[(N_unbalanced + 1): ]), xr, rep_array(0, 1), pstream__, 1e-8, 1e-8, 1e5)"));
        current_statement_begin__ = 163;
        return stan::math::promote_scalar<fun_return_scalar_t__>(subtract(to_vector(balanced_new), balanced));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct steady_state_function_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& balanced,
                          const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& theta,
                          const std::vector<T2__>& xr,
                          const std::vector<int>& xi, std::ostream* pstream__) const {
        return steady_state_function(balanced, theta, xr, xi, pstream__);
    }
};

class inference_model_linear_model
  : public stan::model::model_base_crtp<inference_model_linear_model> {
private:
        int N_balanced;
        int N_unbalanced;
        int N_kinetic_parameter;
        int N_reaction;
        int N_enzyme;
        int N_experiment;
        int N_flux_measurement;
        int N_conc_measurement;
        std::vector<int> experiment_yconc;
        std::vector<int> metabolite_yconc;
        vector_d yconc;
        vector_d sigma_conc;
        std::vector<int> experiment_yflux;
        std::vector<int> reaction_yflux;
        vector_d yflux;
        vector_d sigma_flux;
        vector_d prior_loc_kinetic_parameter;
        vector_d prior_scale_kinetic_parameter;
        std::vector<std::vector<double> > prior_loc_unbalanced;
        std::vector<std::vector<double> > prior_scale_unbalanced;
        std::vector<std::vector<double> > prior_loc_enzyme;
        std::vector<std::vector<double> > prior_scale_enzyme;
        vector_d balanced_guess;
        double rel_tol;
        double f_tol;
        int max_steps;
        int LIKELIHOOD;
        std::vector<double> xr;
        std::vector<int> xi;
public:
    inference_model_linear_model(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : model_base_crtp(0) {
        ctor_body(context__, 0, pstream__);
    }

    inference_model_linear_model(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : model_base_crtp(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        typedef double local_scalar_t__;

        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "inference_model_linear_model_namespace::inference_model_linear_model";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            // initialize data block variables from context__
            current_statement_begin__ = 168;
            context__.validate_dims("data initialization", "N_balanced", "int", context__.to_vec());
            N_balanced = int(0);
            vals_i__ = context__.vals_i("N_balanced");
            pos__ = 0;
            N_balanced = vals_i__[pos__++];
            check_greater_or_equal(function__, "N_balanced", N_balanced, 1);

            current_statement_begin__ = 169;
            context__.validate_dims("data initialization", "N_unbalanced", "int", context__.to_vec());
            N_unbalanced = int(0);
            vals_i__ = context__.vals_i("N_unbalanced");
            pos__ = 0;
            N_unbalanced = vals_i__[pos__++];
            check_greater_or_equal(function__, "N_unbalanced", N_unbalanced, 1);

            current_statement_begin__ = 170;
            context__.validate_dims("data initialization", "N_kinetic_parameter", "int", context__.to_vec());
            N_kinetic_parameter = int(0);
            vals_i__ = context__.vals_i("N_kinetic_parameter");
            pos__ = 0;
            N_kinetic_parameter = vals_i__[pos__++];
            check_greater_or_equal(function__, "N_kinetic_parameter", N_kinetic_parameter, 1);

            current_statement_begin__ = 171;
            context__.validate_dims("data initialization", "N_reaction", "int", context__.to_vec());
            N_reaction = int(0);
            vals_i__ = context__.vals_i("N_reaction");
            pos__ = 0;
            N_reaction = vals_i__[pos__++];
            check_greater_or_equal(function__, "N_reaction", N_reaction, 1);

            current_statement_begin__ = 172;
            context__.validate_dims("data initialization", "N_enzyme", "int", context__.to_vec());
            N_enzyme = int(0);
            vals_i__ = context__.vals_i("N_enzyme");
            pos__ = 0;
            N_enzyme = vals_i__[pos__++];
            check_greater_or_equal(function__, "N_enzyme", N_enzyme, 1);

            current_statement_begin__ = 173;
            context__.validate_dims("data initialization", "N_experiment", "int", context__.to_vec());
            N_experiment = int(0);
            vals_i__ = context__.vals_i("N_experiment");
            pos__ = 0;
            N_experiment = vals_i__[pos__++];
            check_greater_or_equal(function__, "N_experiment", N_experiment, 1);

            current_statement_begin__ = 174;
            context__.validate_dims("data initialization", "N_flux_measurement", "int", context__.to_vec());
            N_flux_measurement = int(0);
            vals_i__ = context__.vals_i("N_flux_measurement");
            pos__ = 0;
            N_flux_measurement = vals_i__[pos__++];
            check_greater_or_equal(function__, "N_flux_measurement", N_flux_measurement, 1);

            current_statement_begin__ = 175;
            context__.validate_dims("data initialization", "N_conc_measurement", "int", context__.to_vec());
            N_conc_measurement = int(0);
            vals_i__ = context__.vals_i("N_conc_measurement");
            pos__ = 0;
            N_conc_measurement = vals_i__[pos__++];
            check_greater_or_equal(function__, "N_conc_measurement", N_conc_measurement, 1);

            current_statement_begin__ = 177;
            validate_non_negative_index("experiment_yconc", "N_conc_measurement", N_conc_measurement);
            context__.validate_dims("data initialization", "experiment_yconc", "int", context__.to_vec(N_conc_measurement));
            experiment_yconc = std::vector<int>(N_conc_measurement, int(0));
            vals_i__ = context__.vals_i("experiment_yconc");
            pos__ = 0;
            size_t experiment_yconc_k_0_max__ = N_conc_measurement;
            for (size_t k_0__ = 0; k_0__ < experiment_yconc_k_0_max__; ++k_0__) {
                experiment_yconc[k_0__] = vals_i__[pos__++];
            }
            size_t experiment_yconc_i_0_max__ = N_conc_measurement;
            for (size_t i_0__ = 0; i_0__ < experiment_yconc_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "experiment_yconc[i_0__]", experiment_yconc[i_0__], 1);
                check_less_or_equal(function__, "experiment_yconc[i_0__]", experiment_yconc[i_0__], N_experiment);
            }

            current_statement_begin__ = 178;
            validate_non_negative_index("metabolite_yconc", "N_conc_measurement", N_conc_measurement);
            context__.validate_dims("data initialization", "metabolite_yconc", "int", context__.to_vec(N_conc_measurement));
            metabolite_yconc = std::vector<int>(N_conc_measurement, int(0));
            vals_i__ = context__.vals_i("metabolite_yconc");
            pos__ = 0;
            size_t metabolite_yconc_k_0_max__ = N_conc_measurement;
            for (size_t k_0__ = 0; k_0__ < metabolite_yconc_k_0_max__; ++k_0__) {
                metabolite_yconc[k_0__] = vals_i__[pos__++];
            }
            size_t metabolite_yconc_i_0_max__ = N_conc_measurement;
            for (size_t i_0__ = 0; i_0__ < metabolite_yconc_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "metabolite_yconc[i_0__]", metabolite_yconc[i_0__], 1);
                check_less_or_equal(function__, "metabolite_yconc[i_0__]", metabolite_yconc[i_0__], (N_balanced + N_unbalanced));
            }

            current_statement_begin__ = 179;
            validate_non_negative_index("yconc", "N_conc_measurement", N_conc_measurement);
            context__.validate_dims("data initialization", "yconc", "vector_d", context__.to_vec(N_conc_measurement));
            yconc = Eigen::Matrix<double, Eigen::Dynamic, 1>(N_conc_measurement);
            vals_r__ = context__.vals_r("yconc");
            pos__ = 0;
            size_t yconc_j_1_max__ = N_conc_measurement;
            for (size_t j_1__ = 0; j_1__ < yconc_j_1_max__; ++j_1__) {
                yconc(j_1__) = vals_r__[pos__++];
            }

            current_statement_begin__ = 180;
            validate_non_negative_index("sigma_conc", "N_conc_measurement", N_conc_measurement);
            context__.validate_dims("data initialization", "sigma_conc", "vector_d", context__.to_vec(N_conc_measurement));
            sigma_conc = Eigen::Matrix<double, Eigen::Dynamic, 1>(N_conc_measurement);
            vals_r__ = context__.vals_r("sigma_conc");
            pos__ = 0;
            size_t sigma_conc_j_1_max__ = N_conc_measurement;
            for (size_t j_1__ = 0; j_1__ < sigma_conc_j_1_max__; ++j_1__) {
                sigma_conc(j_1__) = vals_r__[pos__++];
            }
            check_greater_or_equal(function__, "sigma_conc", sigma_conc, 0);

            current_statement_begin__ = 181;
            validate_non_negative_index("experiment_yflux", "N_flux_measurement", N_flux_measurement);
            context__.validate_dims("data initialization", "experiment_yflux", "int", context__.to_vec(N_flux_measurement));
            experiment_yflux = std::vector<int>(N_flux_measurement, int(0));
            vals_i__ = context__.vals_i("experiment_yflux");
            pos__ = 0;
            size_t experiment_yflux_k_0_max__ = N_flux_measurement;
            for (size_t k_0__ = 0; k_0__ < experiment_yflux_k_0_max__; ++k_0__) {
                experiment_yflux[k_0__] = vals_i__[pos__++];
            }
            size_t experiment_yflux_i_0_max__ = N_flux_measurement;
            for (size_t i_0__ = 0; i_0__ < experiment_yflux_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "experiment_yflux[i_0__]", experiment_yflux[i_0__], 1);
                check_less_or_equal(function__, "experiment_yflux[i_0__]", experiment_yflux[i_0__], N_experiment);
            }

            current_statement_begin__ = 182;
            validate_non_negative_index("reaction_yflux", "N_flux_measurement", N_flux_measurement);
            context__.validate_dims("data initialization", "reaction_yflux", "int", context__.to_vec(N_flux_measurement));
            reaction_yflux = std::vector<int>(N_flux_measurement, int(0));
            vals_i__ = context__.vals_i("reaction_yflux");
            pos__ = 0;
            size_t reaction_yflux_k_0_max__ = N_flux_measurement;
            for (size_t k_0__ = 0; k_0__ < reaction_yflux_k_0_max__; ++k_0__) {
                reaction_yflux[k_0__] = vals_i__[pos__++];
            }
            size_t reaction_yflux_i_0_max__ = N_flux_measurement;
            for (size_t i_0__ = 0; i_0__ < reaction_yflux_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "reaction_yflux[i_0__]", reaction_yflux[i_0__], 1);
                check_less_or_equal(function__, "reaction_yflux[i_0__]", reaction_yflux[i_0__], N_reaction);
            }

            current_statement_begin__ = 183;
            validate_non_negative_index("yflux", "N_flux_measurement", N_flux_measurement);
            context__.validate_dims("data initialization", "yflux", "vector_d", context__.to_vec(N_flux_measurement));
            yflux = Eigen::Matrix<double, Eigen::Dynamic, 1>(N_flux_measurement);
            vals_r__ = context__.vals_r("yflux");
            pos__ = 0;
            size_t yflux_j_1_max__ = N_flux_measurement;
            for (size_t j_1__ = 0; j_1__ < yflux_j_1_max__; ++j_1__) {
                yflux(j_1__) = vals_r__[pos__++];
            }

            current_statement_begin__ = 184;
            validate_non_negative_index("sigma_flux", "N_flux_measurement", N_flux_measurement);
            context__.validate_dims("data initialization", "sigma_flux", "vector_d", context__.to_vec(N_flux_measurement));
            sigma_flux = Eigen::Matrix<double, Eigen::Dynamic, 1>(N_flux_measurement);
            vals_r__ = context__.vals_r("sigma_flux");
            pos__ = 0;
            size_t sigma_flux_j_1_max__ = N_flux_measurement;
            for (size_t j_1__ = 0; j_1__ < sigma_flux_j_1_max__; ++j_1__) {
                sigma_flux(j_1__) = vals_r__[pos__++];
            }
            check_greater_or_equal(function__, "sigma_flux", sigma_flux, 0);

            current_statement_begin__ = 186;
            validate_non_negative_index("prior_loc_kinetic_parameter", "N_kinetic_parameter", N_kinetic_parameter);
            context__.validate_dims("data initialization", "prior_loc_kinetic_parameter", "vector_d", context__.to_vec(N_kinetic_parameter));
            prior_loc_kinetic_parameter = Eigen::Matrix<double, Eigen::Dynamic, 1>(N_kinetic_parameter);
            vals_r__ = context__.vals_r("prior_loc_kinetic_parameter");
            pos__ = 0;
            size_t prior_loc_kinetic_parameter_j_1_max__ = N_kinetic_parameter;
            for (size_t j_1__ = 0; j_1__ < prior_loc_kinetic_parameter_j_1_max__; ++j_1__) {
                prior_loc_kinetic_parameter(j_1__) = vals_r__[pos__++];
            }

            current_statement_begin__ = 187;
            validate_non_negative_index("prior_scale_kinetic_parameter", "N_kinetic_parameter", N_kinetic_parameter);
            context__.validate_dims("data initialization", "prior_scale_kinetic_parameter", "vector_d", context__.to_vec(N_kinetic_parameter));
            prior_scale_kinetic_parameter = Eigen::Matrix<double, Eigen::Dynamic, 1>(N_kinetic_parameter);
            vals_r__ = context__.vals_r("prior_scale_kinetic_parameter");
            pos__ = 0;
            size_t prior_scale_kinetic_parameter_j_1_max__ = N_kinetic_parameter;
            for (size_t j_1__ = 0; j_1__ < prior_scale_kinetic_parameter_j_1_max__; ++j_1__) {
                prior_scale_kinetic_parameter(j_1__) = vals_r__[pos__++];
            }
            check_greater_or_equal(function__, "prior_scale_kinetic_parameter", prior_scale_kinetic_parameter, 0);

            current_statement_begin__ = 188;
            validate_non_negative_index("prior_loc_unbalanced", "N_unbalanced", N_unbalanced);
            validate_non_negative_index("prior_loc_unbalanced", "N_experiment", N_experiment);
            context__.validate_dims("data initialization", "prior_loc_unbalanced", "double", context__.to_vec(N_unbalanced,N_experiment));
            prior_loc_unbalanced = std::vector<std::vector<double> >(N_unbalanced, std::vector<double>(N_experiment, double(0)));
            vals_r__ = context__.vals_r("prior_loc_unbalanced");
            pos__ = 0;
            size_t prior_loc_unbalanced_k_0_max__ = N_unbalanced;
            size_t prior_loc_unbalanced_k_1_max__ = N_experiment;
            for (size_t k_1__ = 0; k_1__ < prior_loc_unbalanced_k_1_max__; ++k_1__) {
                for (size_t k_0__ = 0; k_0__ < prior_loc_unbalanced_k_0_max__; ++k_0__) {
                    prior_loc_unbalanced[k_0__][k_1__] = vals_r__[pos__++];
                }
            }

            current_statement_begin__ = 189;
            validate_non_negative_index("prior_scale_unbalanced", "N_unbalanced", N_unbalanced);
            validate_non_negative_index("prior_scale_unbalanced", "N_experiment", N_experiment);
            context__.validate_dims("data initialization", "prior_scale_unbalanced", "double", context__.to_vec(N_unbalanced,N_experiment));
            prior_scale_unbalanced = std::vector<std::vector<double> >(N_unbalanced, std::vector<double>(N_experiment, double(0)));
            vals_r__ = context__.vals_r("prior_scale_unbalanced");
            pos__ = 0;
            size_t prior_scale_unbalanced_k_0_max__ = N_unbalanced;
            size_t prior_scale_unbalanced_k_1_max__ = N_experiment;
            for (size_t k_1__ = 0; k_1__ < prior_scale_unbalanced_k_1_max__; ++k_1__) {
                for (size_t k_0__ = 0; k_0__ < prior_scale_unbalanced_k_0_max__; ++k_0__) {
                    prior_scale_unbalanced[k_0__][k_1__] = vals_r__[pos__++];
                }
            }
            size_t prior_scale_unbalanced_i_0_max__ = N_unbalanced;
            size_t prior_scale_unbalanced_i_1_max__ = N_experiment;
            for (size_t i_0__ = 0; i_0__ < prior_scale_unbalanced_i_0_max__; ++i_0__) {
                for (size_t i_1__ = 0; i_1__ < prior_scale_unbalanced_i_1_max__; ++i_1__) {
                    check_greater_or_equal(function__, "prior_scale_unbalanced[i_0__][i_1__]", prior_scale_unbalanced[i_0__][i_1__], 0);
                }
            }

            current_statement_begin__ = 190;
            validate_non_negative_index("prior_loc_enzyme", "N_enzyme", N_enzyme);
            validate_non_negative_index("prior_loc_enzyme", "N_experiment", N_experiment);
            context__.validate_dims("data initialization", "prior_loc_enzyme", "double", context__.to_vec(N_enzyme,N_experiment));
            prior_loc_enzyme = std::vector<std::vector<double> >(N_enzyme, std::vector<double>(N_experiment, double(0)));
            vals_r__ = context__.vals_r("prior_loc_enzyme");
            pos__ = 0;
            size_t prior_loc_enzyme_k_0_max__ = N_enzyme;
            size_t prior_loc_enzyme_k_1_max__ = N_experiment;
            for (size_t k_1__ = 0; k_1__ < prior_loc_enzyme_k_1_max__; ++k_1__) {
                for (size_t k_0__ = 0; k_0__ < prior_loc_enzyme_k_0_max__; ++k_0__) {
                    prior_loc_enzyme[k_0__][k_1__] = vals_r__[pos__++];
                }
            }

            current_statement_begin__ = 191;
            validate_non_negative_index("prior_scale_enzyme", "N_enzyme", N_enzyme);
            validate_non_negative_index("prior_scale_enzyme", "N_experiment", N_experiment);
            context__.validate_dims("data initialization", "prior_scale_enzyme", "double", context__.to_vec(N_enzyme,N_experiment));
            prior_scale_enzyme = std::vector<std::vector<double> >(N_enzyme, std::vector<double>(N_experiment, double(0)));
            vals_r__ = context__.vals_r("prior_scale_enzyme");
            pos__ = 0;
            size_t prior_scale_enzyme_k_0_max__ = N_enzyme;
            size_t prior_scale_enzyme_k_1_max__ = N_experiment;
            for (size_t k_1__ = 0; k_1__ < prior_scale_enzyme_k_1_max__; ++k_1__) {
                for (size_t k_0__ = 0; k_0__ < prior_scale_enzyme_k_0_max__; ++k_0__) {
                    prior_scale_enzyme[k_0__][k_1__] = vals_r__[pos__++];
                }
            }
            size_t prior_scale_enzyme_i_0_max__ = N_enzyme;
            size_t prior_scale_enzyme_i_1_max__ = N_experiment;
            for (size_t i_0__ = 0; i_0__ < prior_scale_enzyme_i_0_max__; ++i_0__) {
                for (size_t i_1__ = 0; i_1__ < prior_scale_enzyme_i_1_max__; ++i_1__) {
                    check_greater_or_equal(function__, "prior_scale_enzyme[i_0__][i_1__]", prior_scale_enzyme[i_0__][i_1__], 0);
                }
            }

            current_statement_begin__ = 192;
            validate_non_negative_index("balanced_guess", "N_balanced", N_balanced);
            context__.validate_dims("data initialization", "balanced_guess", "vector_d", context__.to_vec(N_balanced));
            balanced_guess = Eigen::Matrix<double, Eigen::Dynamic, 1>(N_balanced);
            vals_r__ = context__.vals_r("balanced_guess");
            pos__ = 0;
            size_t balanced_guess_j_1_max__ = N_balanced;
            for (size_t j_1__ = 0; j_1__ < balanced_guess_j_1_max__; ++j_1__) {
                balanced_guess(j_1__) = vals_r__[pos__++];
            }
            check_greater_or_equal(function__, "balanced_guess", balanced_guess, 0);

            current_statement_begin__ = 194;
            context__.validate_dims("data initialization", "rel_tol", "double", context__.to_vec());
            rel_tol = double(0);
            vals_r__ = context__.vals_r("rel_tol");
            pos__ = 0;
            rel_tol = vals_r__[pos__++];

            current_statement_begin__ = 195;
            context__.validate_dims("data initialization", "f_tol", "double", context__.to_vec());
            f_tol = double(0);
            vals_r__ = context__.vals_r("f_tol");
            pos__ = 0;
            f_tol = vals_r__[pos__++];

            current_statement_begin__ = 196;
            context__.validate_dims("data initialization", "max_steps", "int", context__.to_vec());
            max_steps = int(0);
            vals_i__ = context__.vals_i("max_steps");
            pos__ = 0;
            max_steps = vals_i__[pos__++];

            current_statement_begin__ = 198;
            context__.validate_dims("data initialization", "LIKELIHOOD", "int", context__.to_vec());
            LIKELIHOOD = int(0);
            vals_i__ = context__.vals_i("LIKELIHOOD");
            pos__ = 0;
            LIKELIHOOD = vals_i__[pos__++];
            check_greater_or_equal(function__, "LIKELIHOOD", LIKELIHOOD, 0);
            check_less_or_equal(function__, "LIKELIHOOD", LIKELIHOOD, 1);


            // initialize transformed data variables
            current_statement_begin__ = 201;
            validate_non_negative_index("xr", "0", 0);
            xr = std::vector<double>(0, double(0));
            stan::math::fill(xr, DUMMY_VAR__);

            current_statement_begin__ = 202;
            validate_non_negative_index("xi", "0", 0);
            xi = std::vector<int>(0, int(0));
            stan::math::fill(xi, std::numeric_limits<int>::min());

            // execute transformed data statements

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 205;
            validate_non_negative_index("kinetic_parameter", "N_kinetic_parameter", N_kinetic_parameter);
            num_params_r__ += N_kinetic_parameter;
            current_statement_begin__ = 206;
            validate_non_negative_index("unbalanced", "N_unbalanced", N_unbalanced);
            validate_non_negative_index("unbalanced", "N_experiment", N_experiment);
            num_params_r__ += (N_unbalanced * N_experiment);
            current_statement_begin__ = 207;
            validate_non_negative_index("enzyme_concentration", "N_enzyme", N_enzyme);
            validate_non_negative_index("enzyme_concentration", "N_experiment", N_experiment);
            num_params_r__ += (N_enzyme * N_experiment);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~inference_model_linear_model() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        typedef double local_scalar_t__;
        stan::io::writer<double> writer__(params_r__, params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        current_statement_begin__ = 205;
        if (!(context__.contains_r("kinetic_parameter")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable kinetic_parameter missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("kinetic_parameter");
        pos__ = 0U;
        validate_non_negative_index("kinetic_parameter", "N_kinetic_parameter", N_kinetic_parameter);
        context__.validate_dims("parameter initialization", "kinetic_parameter", "vector_d", context__.to_vec(N_kinetic_parameter));
        Eigen::Matrix<double, Eigen::Dynamic, 1> kinetic_parameter(N_kinetic_parameter);
        size_t kinetic_parameter_j_1_max__ = N_kinetic_parameter;
        for (size_t j_1__ = 0; j_1__ < kinetic_parameter_j_1_max__; ++j_1__) {
            kinetic_parameter(j_1__) = vals_r__[pos__++];
        }
        try {
            writer__.vector_lb_unconstrain(0, kinetic_parameter);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable kinetic_parameter: ") + e.what()), current_statement_begin__, prog_reader__());
        }

        current_statement_begin__ = 206;
        if (!(context__.contains_r("unbalanced")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable unbalanced missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("unbalanced");
        pos__ = 0U;
        validate_non_negative_index("unbalanced", "N_unbalanced", N_unbalanced);
        validate_non_negative_index("unbalanced", "N_experiment", N_experiment);
        context__.validate_dims("parameter initialization", "unbalanced", "vector_d", context__.to_vec(N_experiment,N_unbalanced));
        std::vector<Eigen::Matrix<double, Eigen::Dynamic, 1> > unbalanced(N_experiment, Eigen::Matrix<double, Eigen::Dynamic, 1>(N_unbalanced));
        size_t unbalanced_j_1_max__ = N_unbalanced;
        size_t unbalanced_k_0_max__ = N_experiment;
        for (size_t j_1__ = 0; j_1__ < unbalanced_j_1_max__; ++j_1__) {
            for (size_t k_0__ = 0; k_0__ < unbalanced_k_0_max__; ++k_0__) {
                unbalanced[k_0__](j_1__) = vals_r__[pos__++];
            }
        }
        size_t unbalanced_i_0_max__ = N_experiment;
        for (size_t i_0__ = 0; i_0__ < unbalanced_i_0_max__; ++i_0__) {
            try {
                writer__.vector_lb_unconstrain(0, unbalanced[i_0__]);
            } catch (const std::exception& e) {
                stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable unbalanced: ") + e.what()), current_statement_begin__, prog_reader__());
            }
        }

        current_statement_begin__ = 207;
        if (!(context__.contains_r("enzyme_concentration")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable enzyme_concentration missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("enzyme_concentration");
        pos__ = 0U;
        validate_non_negative_index("enzyme_concentration", "N_enzyme", N_enzyme);
        validate_non_negative_index("enzyme_concentration", "N_experiment", N_experiment);
        context__.validate_dims("parameter initialization", "enzyme_concentration", "vector_d", context__.to_vec(N_experiment,N_enzyme));
        std::vector<Eigen::Matrix<double, Eigen::Dynamic, 1> > enzyme_concentration(N_experiment, Eigen::Matrix<double, Eigen::Dynamic, 1>(N_enzyme));
        size_t enzyme_concentration_j_1_max__ = N_enzyme;
        size_t enzyme_concentration_k_0_max__ = N_experiment;
        for (size_t j_1__ = 0; j_1__ < enzyme_concentration_j_1_max__; ++j_1__) {
            for (size_t k_0__ = 0; k_0__ < enzyme_concentration_k_0_max__; ++k_0__) {
                enzyme_concentration[k_0__](j_1__) = vals_r__[pos__++];
            }
        }
        size_t enzyme_concentration_i_0_max__ = N_experiment;
        for (size_t i_0__ = 0; i_0__ < enzyme_concentration_i_0_max__; ++i_0__) {
            try {
                writer__.vector_lb_unconstrain(0, enzyme_concentration[i_0__]);
            } catch (const std::exception& e) {
                stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable enzyme_concentration: ") + e.what()), current_statement_begin__, prog_reader__());
            }
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(std::vector<T__>& params_r__,
                 std::vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        typedef T__ local_scalar_t__;

        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // dummy to suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;
        try {
            stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);

            // model parameters
            current_statement_begin__ = 205;
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> kinetic_parameter;
            (void) kinetic_parameter;  // dummy to suppress unused var warning
            if (jacobian__)
                kinetic_parameter = in__.vector_lb_constrain(0, N_kinetic_parameter, lp__);
            else
                kinetic_parameter = in__.vector_lb_constrain(0, N_kinetic_parameter);

            current_statement_begin__ = 206;
            std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> > unbalanced;
            size_t unbalanced_d_0_max__ = N_experiment;
            unbalanced.reserve(unbalanced_d_0_max__);
            for (size_t d_0__ = 0; d_0__ < unbalanced_d_0_max__; ++d_0__) {
                if (jacobian__)
                    unbalanced.push_back(in__.vector_lb_constrain(0, N_unbalanced, lp__));
                else
                    unbalanced.push_back(in__.vector_lb_constrain(0, N_unbalanced));
            }

            current_statement_begin__ = 207;
            std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> > enzyme_concentration;
            size_t enzyme_concentration_d_0_max__ = N_experiment;
            enzyme_concentration.reserve(enzyme_concentration_d_0_max__);
            for (size_t d_0__ = 0; d_0__ < enzyme_concentration_d_0_max__; ++d_0__) {
                if (jacobian__)
                    enzyme_concentration.push_back(in__.vector_lb_constrain(0, N_enzyme, lp__));
                else
                    enzyme_concentration.push_back(in__.vector_lb_constrain(0, N_enzyme));
            }

            // transformed parameters
            current_statement_begin__ = 210;
            validate_non_negative_index("conc", "(N_balanced + N_unbalanced)", (N_balanced + N_unbalanced));
            validate_non_negative_index("conc", "N_experiment", N_experiment);
            std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> > conc(N_experiment, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>((N_balanced + N_unbalanced)));
            stan::math::initialize(conc, DUMMY_VAR__);
            stan::math::fill(conc, DUMMY_VAR__);

            current_statement_begin__ = 211;
            validate_non_negative_index("flux", "N_reaction", N_reaction);
            validate_non_negative_index("flux", "N_experiment", N_experiment);
            std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> > flux(N_experiment, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(N_reaction));
            stan::math::initialize(flux, DUMMY_VAR__);
            stan::math::fill(flux, DUMMY_VAR__);

            // transformed parameters block statements
            current_statement_begin__ = 212;
            for (int e = 1; e <= N_experiment; ++e) {
                {
                current_statement_begin__ = 213;
                validate_non_negative_index("theta", "((N_unbalanced + N_enzyme) + N_kinetic_parameter)", ((N_unbalanced + N_enzyme) + N_kinetic_parameter));
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> theta(((N_unbalanced + N_enzyme) + N_kinetic_parameter));
                stan::math::initialize(theta, DUMMY_VAR__);
                stan::math::fill(theta, DUMMY_VAR__);
                stan::math::assign(theta,append_row(get_base1(unbalanced, e, "unbalanced", 1), append_row(get_base1(enzyme_concentration, e, "enzyme_concentration", 1), kinetic_parameter)));


                current_statement_begin__ = 214;
                stan::model::assign(conc, 
                            stan::model::cons_list(stan::model::index_uni(e), stan::model::cons_list(stan::model::index_multi(static_cast<std::vector<int> >(stan::math::array_builder<int >().add(3).add(4).array())), stan::model::nil_index_list())), 
                            algebra_solver(steady_state_function_functor__(), balanced_guess, theta, xr, xi, pstream__, rel_tol, f_tol, max_steps), 
                            "assigning variable conc");
                current_statement_begin__ = 215;
                stan::model::assign(conc, 
                            stan::model::cons_list(stan::model::index_uni(e), stan::model::cons_list(stan::model::index_multi(static_cast<std::vector<int> >(stan::math::array_builder<int >().add(1).add(2).array())), stan::model::nil_index_list())), 
                            get_base1(unbalanced, e, "unbalanced", 1), 
                            "assigning variable conc");
                current_statement_begin__ = 216;
                stan::model::assign(flux, 
                            stan::model::cons_list(stan::model::index_uni(e), stan::model::nil_index_list()), 
                            get_fluxes(to_array_1d(get_base1(conc, e, "conc", 1)), append_array(to_array_1d(get_base1(enzyme_concentration, e, "enzyme_concentration", 1)), to_array_1d(kinetic_parameter)), pstream__), 
                            "assigning variable flux");
                }
            }

            // validate transformed parameters
            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning

            current_statement_begin__ = 210;
            size_t conc_k_0_max__ = N_experiment;
            size_t conc_j_1_max__ = (N_balanced + N_unbalanced);
            for (size_t k_0__ = 0; k_0__ < conc_k_0_max__; ++k_0__) {
                for (size_t j_1__ = 0; j_1__ < conc_j_1_max__; ++j_1__) {
                    if (stan::math::is_uninitialized(conc[k_0__](j_1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: conc" << "[" << k_0__ << "]" << "(" << j_1__ << ")";
                        stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable conc: ") + msg__.str()), current_statement_begin__, prog_reader__());
                    }
                }
            }
            size_t conc_i_0_max__ = N_experiment;
            for (size_t i_0__ = 0; i_0__ < conc_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "conc[i_0__]", conc[i_0__], 0);
            }

            current_statement_begin__ = 211;
            size_t flux_k_0_max__ = N_experiment;
            size_t flux_j_1_max__ = N_reaction;
            for (size_t k_0__ = 0; k_0__ < flux_k_0_max__; ++k_0__) {
                for (size_t j_1__ = 0; j_1__ < flux_j_1_max__; ++j_1__) {
                    if (stan::math::is_uninitialized(flux[k_0__](j_1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: flux" << "[" << k_0__ << "]" << "(" << j_1__ << ")";
                        stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable flux: ") + msg__.str()), current_statement_begin__, prog_reader__());
                    }
                }
            }

            // model body

            current_statement_begin__ = 220;
            lp_accum__.add(lognormal_log<propto__>(kinetic_parameter, stan::math::log(prior_loc_kinetic_parameter), prior_scale_kinetic_parameter));
            current_statement_begin__ = 221;
            for (int e = 1; e <= N_experiment; ++e) {

                current_statement_begin__ = 222;
                lp_accum__.add(lognormal_log<propto__>(get_base1(unbalanced, e, "unbalanced", 1), stan::math::log(stan::model::rvalue(prior_loc_unbalanced, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(e), stan::model::nil_index_list())), "prior_loc_unbalanced")), stan::model::rvalue(prior_scale_unbalanced, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(e), stan::model::nil_index_list())), "prior_scale_unbalanced")));
                current_statement_begin__ = 223;
                lp_accum__.add(lognormal_log<propto__>(get_base1(enzyme_concentration, e, "enzyme_concentration", 1), stan::math::log(stan::model::rvalue(prior_loc_enzyme, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(e), stan::model::nil_index_list())), "prior_loc_enzyme")), stan::model::rvalue(prior_scale_enzyme, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(e), stan::model::nil_index_list())), "prior_scale_enzyme")));
            }
            current_statement_begin__ = 225;
            if (as_bool(logical_eq(LIKELIHOOD, 1))) {

                current_statement_begin__ = 226;
                for (int c = 1; c <= N_conc_measurement; ++c) {

                    current_statement_begin__ = 227;
                    lp_accum__.add(lognormal_log(get_base1(yconc, c, "yconc", 1), stan::math::log(get_base1(get_base1(conc, get_base1(experiment_yconc, c, "experiment_yconc", 1), "conc", 1), get_base1(metabolite_yconc, c, "metabolite_yconc", 1), "conc", 2)), get_base1(sigma_conc, c, "sigma_conc", 1)));
                }
                current_statement_begin__ = 229;
                for (int f = 1; f <= N_flux_measurement; ++f) {

                    current_statement_begin__ = 230;
                    lp_accum__.add(normal_log(get_base1(yflux, f, "yflux", 1), get_base1(get_base1(flux, get_base1(experiment_yflux, f, "experiment_yflux", 1), "flux", 1), get_base1(reaction_yflux, f, "reaction_yflux", 1), "flux", 2), get_base1(sigma_flux, f, "sigma_flux", 1)));
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("kinetic_parameter");
        names__.push_back("unbalanced");
        names__.push_back("enzyme_concentration");
        names__.push_back("conc");
        names__.push_back("flux");
        names__.push_back("yconc_sim");
        names__.push_back("yflux_sim");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(N_kinetic_parameter);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_experiment);
        dims__.push_back(N_unbalanced);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_experiment);
        dims__.push_back(N_enzyme);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_experiment);
        dims__.push_back((N_balanced + N_unbalanced));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_experiment);
        dims__.push_back(N_reaction);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_conc_measurement);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_flux_measurement);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        typedef double local_scalar_t__;

        vars__.resize(0);
        stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
        static const char* function__ = "inference_model_linear_model_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning

        // read-transform, write parameters
        Eigen::Matrix<double, Eigen::Dynamic, 1> kinetic_parameter = in__.vector_lb_constrain(0, N_kinetic_parameter);
        size_t kinetic_parameter_j_1_max__ = N_kinetic_parameter;
        for (size_t j_1__ = 0; j_1__ < kinetic_parameter_j_1_max__; ++j_1__) {
            vars__.push_back(kinetic_parameter(j_1__));
        }

        std::vector<Eigen::Matrix<double, Eigen::Dynamic, 1> > unbalanced;
        size_t unbalanced_d_0_max__ = N_experiment;
        unbalanced.reserve(unbalanced_d_0_max__);
        for (size_t d_0__ = 0; d_0__ < unbalanced_d_0_max__; ++d_0__) {
            unbalanced.push_back(in__.vector_lb_constrain(0, N_unbalanced));
        }
        size_t unbalanced_j_1_max__ = N_unbalanced;
        size_t unbalanced_k_0_max__ = N_experiment;
        for (size_t j_1__ = 0; j_1__ < unbalanced_j_1_max__; ++j_1__) {
            for (size_t k_0__ = 0; k_0__ < unbalanced_k_0_max__; ++k_0__) {
                vars__.push_back(unbalanced[k_0__](j_1__));
            }
        }

        std::vector<Eigen::Matrix<double, Eigen::Dynamic, 1> > enzyme_concentration;
        size_t enzyme_concentration_d_0_max__ = N_experiment;
        enzyme_concentration.reserve(enzyme_concentration_d_0_max__);
        for (size_t d_0__ = 0; d_0__ < enzyme_concentration_d_0_max__; ++d_0__) {
            enzyme_concentration.push_back(in__.vector_lb_constrain(0, N_enzyme));
        }
        size_t enzyme_concentration_j_1_max__ = N_enzyme;
        size_t enzyme_concentration_k_0_max__ = N_experiment;
        for (size_t j_1__ = 0; j_1__ < enzyme_concentration_j_1_max__; ++j_1__) {
            for (size_t k_0__ = 0; k_0__ < enzyme_concentration_k_0_max__; ++k_0__) {
                vars__.push_back(enzyme_concentration[k_0__](j_1__));
            }
        }

        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        if (!include_tparams__ && !include_gqs__) return;

        try {
            // declare and define transformed parameters
            current_statement_begin__ = 210;
            validate_non_negative_index("conc", "(N_balanced + N_unbalanced)", (N_balanced + N_unbalanced));
            validate_non_negative_index("conc", "N_experiment", N_experiment);
            std::vector<Eigen::Matrix<double, Eigen::Dynamic, 1> > conc(N_experiment, Eigen::Matrix<double, Eigen::Dynamic, 1>((N_balanced + N_unbalanced)));
            stan::math::initialize(conc, DUMMY_VAR__);
            stan::math::fill(conc, DUMMY_VAR__);

            current_statement_begin__ = 211;
            validate_non_negative_index("flux", "N_reaction", N_reaction);
            validate_non_negative_index("flux", "N_experiment", N_experiment);
            std::vector<Eigen::Matrix<double, Eigen::Dynamic, 1> > flux(N_experiment, Eigen::Matrix<double, Eigen::Dynamic, 1>(N_reaction));
            stan::math::initialize(flux, DUMMY_VAR__);
            stan::math::fill(flux, DUMMY_VAR__);

            // do transformed parameters statements
            current_statement_begin__ = 212;
            for (int e = 1; e <= N_experiment; ++e) {
                {
                current_statement_begin__ = 213;
                validate_non_negative_index("theta", "((N_unbalanced + N_enzyme) + N_kinetic_parameter)", ((N_unbalanced + N_enzyme) + N_kinetic_parameter));
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> theta(((N_unbalanced + N_enzyme) + N_kinetic_parameter));
                stan::math::initialize(theta, DUMMY_VAR__);
                stan::math::fill(theta, DUMMY_VAR__);
                stan::math::assign(theta,append_row(get_base1(unbalanced, e, "unbalanced", 1), append_row(get_base1(enzyme_concentration, e, "enzyme_concentration", 1), kinetic_parameter)));


                current_statement_begin__ = 214;
                stan::model::assign(conc, 
                            stan::model::cons_list(stan::model::index_uni(e), stan::model::cons_list(stan::model::index_multi(static_cast<std::vector<int> >(stan::math::array_builder<int >().add(3).add(4).array())), stan::model::nil_index_list())), 
                            algebra_solver(steady_state_function_functor__(), balanced_guess, theta, xr, xi, pstream__, rel_tol, f_tol, max_steps), 
                            "assigning variable conc");
                current_statement_begin__ = 215;
                stan::model::assign(conc, 
                            stan::model::cons_list(stan::model::index_uni(e), stan::model::cons_list(stan::model::index_multi(static_cast<std::vector<int> >(stan::math::array_builder<int >().add(1).add(2).array())), stan::model::nil_index_list())), 
                            get_base1(unbalanced, e, "unbalanced", 1), 
                            "assigning variable conc");
                current_statement_begin__ = 216;
                stan::model::assign(flux, 
                            stan::model::cons_list(stan::model::index_uni(e), stan::model::nil_index_list()), 
                            get_fluxes(to_array_1d(get_base1(conc, e, "conc", 1)), append_array(to_array_1d(get_base1(enzyme_concentration, e, "enzyme_concentration", 1)), to_array_1d(kinetic_parameter)), pstream__), 
                            "assigning variable flux");
                }
            }

            if (!include_gqs__ && !include_tparams__) return;
            // validate transformed parameters
            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning

            current_statement_begin__ = 210;
            size_t conc_i_0_max__ = N_experiment;
            for (size_t i_0__ = 0; i_0__ < conc_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "conc[i_0__]", conc[i_0__], 0);
            }

            // write transformed parameters
            if (include_tparams__) {
                size_t conc_j_1_max__ = (N_balanced + N_unbalanced);
                size_t conc_k_0_max__ = N_experiment;
                for (size_t j_1__ = 0; j_1__ < conc_j_1_max__; ++j_1__) {
                    for (size_t k_0__ = 0; k_0__ < conc_k_0_max__; ++k_0__) {
                        vars__.push_back(conc[k_0__](j_1__));
                    }
                }
                size_t flux_j_1_max__ = N_reaction;
                size_t flux_k_0_max__ = N_experiment;
                for (size_t j_1__ = 0; j_1__ < flux_j_1_max__; ++j_1__) {
                    for (size_t k_0__ = 0; k_0__ < flux_k_0_max__; ++k_0__) {
                        vars__.push_back(flux[k_0__](j_1__));
                    }
                }
            }
            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 235;
            validate_non_negative_index("yconc_sim", "N_conc_measurement", N_conc_measurement);
            Eigen::Matrix<double, Eigen::Dynamic, 1> yconc_sim(N_conc_measurement);
            stan::math::initialize(yconc_sim, DUMMY_VAR__);
            stan::math::fill(yconc_sim, DUMMY_VAR__);

            current_statement_begin__ = 236;
            validate_non_negative_index("yflux_sim", "N_flux_measurement", N_flux_measurement);
            Eigen::Matrix<double, Eigen::Dynamic, 1> yflux_sim(N_flux_measurement);
            stan::math::initialize(yflux_sim, DUMMY_VAR__);
            stan::math::fill(yflux_sim, DUMMY_VAR__);

            // generated quantities statements
            current_statement_begin__ = 237;
            for (int c = 1; c <= N_conc_measurement; ++c) {

                current_statement_begin__ = 238;
                stan::model::assign(yconc_sim, 
                            stan::model::cons_list(stan::model::index_uni(c), stan::model::nil_index_list()), 
                            lognormal_rng(stan::math::log(get_base1(get_base1(conc, get_base1(experiment_yconc, c, "experiment_yconc", 1), "conc", 1), get_base1(metabolite_yconc, c, "metabolite_yconc", 1), "conc", 2)), get_base1(sigma_conc, c, "sigma_conc", 1), base_rng__), 
                            "assigning variable yconc_sim");
            }
            current_statement_begin__ = 240;
            for (int f = 1; f <= N_flux_measurement; ++f) {

                current_statement_begin__ = 241;
                stan::model::assign(yflux_sim, 
                            stan::model::cons_list(stan::model::index_uni(f), stan::model::nil_index_list()), 
                            normal_rng(get_base1(get_base1(flux, get_base1(experiment_yflux, f, "experiment_yflux", 1), "flux", 1), get_base1(reaction_yflux, f, "reaction_yflux", 1), "flux", 2), get_base1(sigma_flux, f, "sigma_flux", 1), base_rng__), 
                            "assigning variable yflux_sim");
            }

            // validate, write generated quantities
            current_statement_begin__ = 235;
            size_t yconc_sim_j_1_max__ = N_conc_measurement;
            for (size_t j_1__ = 0; j_1__ < yconc_sim_j_1_max__; ++j_1__) {
                vars__.push_back(yconc_sim(j_1__));
            }

            current_statement_begin__ = 236;
            size_t yflux_sim_j_1_max__ = N_flux_measurement;
            for (size_t j_1__ = 0; j_1__ < yflux_sim_j_1_max__; ++j_1__) {
                vars__.push_back(yflux_sim(j_1__));
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng, params_r_vec, params_i_vec, vars_vec, include_tparams, include_gqs, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    std::string model_name() const {
        return "inference_model_linear_model";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        size_t kinetic_parameter_j_1_max__ = N_kinetic_parameter;
        for (size_t j_1__ = 0; j_1__ < kinetic_parameter_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "kinetic_parameter" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t unbalanced_j_1_max__ = N_unbalanced;
        size_t unbalanced_k_0_max__ = N_experiment;
        for (size_t j_1__ = 0; j_1__ < unbalanced_j_1_max__; ++j_1__) {
            for (size_t k_0__ = 0; k_0__ < unbalanced_k_0_max__; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "unbalanced" << '.' << k_0__ + 1 << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t enzyme_concentration_j_1_max__ = N_enzyme;
        size_t enzyme_concentration_k_0_max__ = N_experiment;
        for (size_t j_1__ = 0; j_1__ < enzyme_concentration_j_1_max__; ++j_1__) {
            for (size_t k_0__ = 0; k_0__ < enzyme_concentration_k_0_max__; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "enzyme_concentration" << '.' << k_0__ + 1 << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__ && !include_tparams__) return;

        if (include_tparams__) {
            size_t conc_j_1_max__ = (N_balanced + N_unbalanced);
            size_t conc_k_0_max__ = N_experiment;
            for (size_t j_1__ = 0; j_1__ < conc_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < conc_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "conc" << '.' << k_0__ + 1 << '.' << j_1__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t flux_j_1_max__ = N_reaction;
            size_t flux_k_0_max__ = N_experiment;
            for (size_t j_1__ = 0; j_1__ < flux_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < flux_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "flux" << '.' << k_0__ + 1 << '.' << j_1__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }

        if (!include_gqs__) return;
        size_t yconc_sim_j_1_max__ = N_conc_measurement;
        for (size_t j_1__ = 0; j_1__ < yconc_sim_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "yconc_sim" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t yflux_sim_j_1_max__ = N_flux_measurement;
        for (size_t j_1__ = 0; j_1__ < yflux_sim_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "yflux_sim" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        size_t kinetic_parameter_j_1_max__ = N_kinetic_parameter;
        for (size_t j_1__ = 0; j_1__ < kinetic_parameter_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "kinetic_parameter" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t unbalanced_j_1_max__ = N_unbalanced;
        size_t unbalanced_k_0_max__ = N_experiment;
        for (size_t j_1__ = 0; j_1__ < unbalanced_j_1_max__; ++j_1__) {
            for (size_t k_0__ = 0; k_0__ < unbalanced_k_0_max__; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "unbalanced" << '.' << k_0__ + 1 << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t enzyme_concentration_j_1_max__ = N_enzyme;
        size_t enzyme_concentration_k_0_max__ = N_experiment;
        for (size_t j_1__ = 0; j_1__ < enzyme_concentration_j_1_max__; ++j_1__) {
            for (size_t k_0__ = 0; k_0__ < enzyme_concentration_k_0_max__; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "enzyme_concentration" << '.' << k_0__ + 1 << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__ && !include_tparams__) return;

        if (include_tparams__) {
            size_t conc_j_1_max__ = (N_balanced + N_unbalanced);
            size_t conc_k_0_max__ = N_experiment;
            for (size_t j_1__ = 0; j_1__ < conc_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < conc_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "conc" << '.' << k_0__ + 1 << '.' << j_1__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t flux_j_1_max__ = N_reaction;
            size_t flux_k_0_max__ = N_experiment;
            for (size_t j_1__ = 0; j_1__ < flux_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < flux_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "flux" << '.' << k_0__ + 1 << '.' << j_1__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }

        if (!include_gqs__) return;
        size_t yconc_sim_j_1_max__ = N_conc_measurement;
        for (size_t j_1__ = 0; j_1__ < yconc_sim_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "yconc_sim" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t yflux_sim_j_1_max__ = N_flux_measurement;
        for (size_t j_1__ = 0; j_1__ < yflux_sim_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "yflux_sim" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
    }

}; // model

}  // namespace

typedef inference_model_linear_model_namespace::inference_model_linear_model stan_model;

stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

